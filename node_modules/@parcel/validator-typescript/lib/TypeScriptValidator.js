"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _typescript() {
  const data = _interopRequireDefault(require("typescript"));

  _typescript = function () {
    return data;
  };

  return data;
}

function _diagnostic() {
  const data = require("@parcel/diagnostic");

  _diagnostic = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _plugin() {
  const data = require("@parcel/plugin");

  _plugin = function () {
    return data;
  };

  return data;
}

function _tsUtils() {
  const data = require("@parcel/ts-utils");

  _tsUtils = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line import/no-extraneous-dependencies
let langServiceCache = {};

var _default = new (_plugin().Validator)({
  async validateAll({
    assets,
    options,
    resolveConfigWithPath
  }) {
    // Build a collection that of all the LanguageServices related to files that just changed.
    let servicesToValidate = new Set();
    await Promise.all(assets.map(async asset => {
      let config = await getConfig(asset, options, resolveConfigWithPath);
      let {
        configHash
      } = config; // Create a languageService/host in the cache for the configuration if it doesn't already exist.

      tryCreateLanguageService(config, asset, options);
      if (!langServiceCache[configHash]) return; // Invalidate the file with the LanguageServiceHost so Typescript knows it has changed.

      langServiceCache[configHash].host.invalidate(asset.filePath);
      servicesToValidate.add(configHash);
    })); // Ask typescript to analyze all changed programs and translate the results into ValidatorResult objects.

    let validatorResults = [];
    servicesToValidate.forEach(configHash => {
      // Make sure that the filesystem being used by the LanguageServiceHost and ParseConfigHost is up-to-date.
      // (This could change in the context of re-running tests, and probably also for other reasons).
      langServiceCache[configHash].host.fs = options.inputFS;
      langServiceCache[configHash].configHost.fs = options.inputFS;
      let program = langServiceCache[configHash].service.getProgram();
      if (!program) return;
      let filesToCheck = program.getSourceFiles();
      filesToCheck.forEach(sourceFile => {
        let diagnostics = program.getSemanticDiagnostics(sourceFile);
        validatorResults.push(getValidateResultFromDiagnostics(sourceFile.fileName, diagnostics));
      });
    });
    return validatorResults;
  }

});

exports.default = _default;

async function getConfig(asset, options, resolveConfigWithPath) {
  let configNames = ['tsconfig.json'];
  let tsconfig = await (0, _utils().loadConfig)(asset.fs, asset.filePath, configNames, options.projectRoot);
  let configPath = await resolveConfigWithPath(configNames, asset.filePath);
  let baseDir = configPath ? _path().default.dirname(configPath) : options.projectRoot;
  let configHash = (tsconfig ? (0, _utils().hashObject)(tsconfig.config) : '') + '-' + baseDir;
  return {
    filepath: configPath,
    baseDir,
    configHash,
    tsconfig: tsconfig === null || tsconfig === void 0 ? void 0 : tsconfig.config
  };
}
/** Tries to create a typescript language service instance in the cache if it doesn't already exist. */


function tryCreateLanguageService(config, asset, options) {
  if (config.tsconfig && !langServiceCache[config.configHash]) {
    // In order to prevent race conditions where we accidentally create two language services for the same config,
    // we need to re-check the cache to see if a service has been created while we were awaiting 'ts'.
    if (!langServiceCache[config.configHash]) {
      let configHost = new (_tsUtils().ParseConfigHost)(options.inputFS, _typescript().default);

      let parsedCommandLine = _typescript().default.parseJsonConfigFileContent(config.tsconfig, configHost, config.baseDir);

      const host = new (_tsUtils().LanguageServiceHost)(options.inputFS, _typescript().default, parsedCommandLine);
      langServiceCache[config.configHash] = {
        configHost,
        host,
        // $FlowFixMe[incompatible-variance]
        // $FlowFixMe[incompatible-call]
        service: _typescript().default.createLanguageService(host, _typescript().default.createDocumentRegistry())
      };
    }
  }
}
/** Translates semantic diagnostics (from TypeScript) into a ValidateResult that Parcel understands. */


function getValidateResultFromDiagnostics(filePath, diagnostics) {
  let validatorResult = {
    warnings: [],
    errors: []
  };

  if (diagnostics.length > 0) {
    for (let diagnostic of diagnostics) {
      let filename = filePath;
      let {
        file
      } = diagnostic;
      let diagnosticMessage = (0, _diagnostic().escapeMarkdown)(typeof diagnostic.messageText === 'string' ? diagnostic.messageText : diagnostic.messageText.messageText);
      let codeframe;

      if (file != null && diagnostic.start != null) {
        let source = file.text || diagnostic.source;

        if (file.fileName) {
          filename = file.fileName;
        }

        if (source) {
          let lineChar = file.getLineAndCharacterOfPosition(diagnostic.start);
          let start = {
            line: lineChar.line + 1,
            column: lineChar.character + 1
          };
          let end = {
            line: start.line,
            column: start.column + 1
          };

          if (typeof diagnostic.start === 'number' && typeof diagnostic.length === 'number') {
            let endCharPosition = file.getLineAndCharacterOfPosition(diagnostic.start + diagnostic.length);
            end = {
              line: endCharPosition.line + 1,
              column: endCharPosition.character + 1
            };
          }

          codeframe = {
            filePath: filename,
            code: source,
            codeHighlights: [{
              start,
              end,
              message: diagnosticMessage
            }]
          };
        }
      }

      validatorResult.errors.push({
        origin: '@parcel/validator-typescript',
        message: diagnosticMessage,
        codeFrames: codeframe ? [codeframe] : undefined
      });
    }
  }

  return validatorResult;
}